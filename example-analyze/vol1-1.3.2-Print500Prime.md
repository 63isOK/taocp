# 质数算法

质数的特点是约数除了1就是自己.

本次话题是:打印前500个质数,打印格式是每行10个,50行,
第一列显示前50个,第二列显示后50个,依次类推.

这个题目要分两部分:找500个质数;按格式打印.

## 算法

    P1. [Start table.] p[1]=2,n=3,j=1.(n表示下一个要判断的数,j表示已有质数数量.)
    P2. [n is prime.] j=j+1;p[j]=n.
    P3. [500 found?] if j==500, go to P9.
    P4. [Advance n.] n=n+2.
    P5. [k=2.] k=2.(用p[k]来测试n是否是一个质数.)
    P6. [p[k]\n?]. p[k]/n,商是q,余数是r.if r==0, go to P4.
    P7. [p[k] large?] if q <= p[k], go to p2.
    P8. [Advance k.] k=k+1, go to p6.
    P9. [Print title.] B[0]=title;print;b=1,m=1.
    P10. [Set up line.] p[m],p[50+m]...p[450+m] 添加到B[b].
    P11. [Print line.] print B[b],b=1-b,m=m+1.if m<=50,go to P10;其他 结束.

## 第一印象

使用了很多数学的方法来巧妙查找质数,
有优化的思想,比如说候选数并去掉了偶数(2的倍数),
最后完整地给出了问题的解.

B数组是一个buf缓冲,其实是有两个
`B[0]`和`B[1]`,一个做打印的时候,另一个做填充.
第一个疑问:支持并发吗,不然为啥要用两个缓冲.是否1个缓冲是否可以.

## 算法分析

第一步,先弄明白代码,再分析算法.

- 定义了一个L,表示前500个质数,也可以换成前2000个质数
- 最终打印在设备18上,u18是行打印设备,字块大小是24word
- PRIME,是数组的起始锚点,后续数组元素的具体位置都是基于PRIME和一个偏移量计算得出的
- BUF0/BUF1,用于存储打印标题和打印的质数
  - 打印标题共25byte,5word,小于一个字块,所以一次OUT就能打完
  - 在buf0/buf1的变量定义和最后的orig/con操作中,都考虑到了u18的字块大小:24
  - 特别说明一下,打印标题并不是存在BUF0中,而是BUF0前面的5word中

现在搞明白的第一个事是运行中的存储情况:

- 前500个质数放在0-499内存单元
- 打印标题5word,放在1995-1999
- BUF0,使用2000-2024;BUF1,使用2025-2049
- 运行代码,从3000开始

第二步,看代码中的查找质数的部分

之前也说到了,mixal写算法,过程重来都不是创造性的,
而是一个算法的翻译过程,整个mixal源码仅仅是将算法的11步做了一个翻译.

现在请跳到源码部分,对着源码完成注释部分.

下面是一些小细节的说明:

- 检查一个数是不是质数,为什么要从`p[1]`开始检测
  - `p[0] = 2, p[1] = 3`
  - 因为第一个添加到质数数组的数是2,第一个待检测的数是3
  - 每次更新待检测数,都是+2,这样排除了所有偶数
  - 也就不需要再去检查是否能整除2,因为永远不会整除2

前500个质数的查找,是按照算法来翻译的,mixal虽然用了一些
编程上的技巧,但这些技巧不是我们追求的,还是回归到算法本质.

第三部,看代码找那个的打印部分

- 将质数转成字符,存在rX时,只取了4个字符,为什么是4?
  - 第500个质数是3571,只有4个字符
  - 从实用角度出发,知道了前500个质数都不超过10000,取4个字符就合理了
  - 另外为了美观,第5个byte为空,整个打印就美观了
- rI5,`p[k]`中的k是如何影响程序的流程的?
  - 在将质数转换成字符之前,也就是取质数时
  - 用的是 LDA PRIME,5  这里可以看出`p[k]`中的k=rI5-1
  - 上面就是所有rI5和k的关系
  - rI5在一行之间,行于行之间,都有应用,最后程序退出也和rI5相关
- rI4,指明的是缓冲中,元素要存的位置,两个缓冲是如何切换的?
  - 涉及到rI4的有如下流程:
    - rI4=BUF1+10,之后一次将行元素写入,rI4最后指向BUF1
    - 处理完一行之后, LD4 24,4 这是重新指定rI4
    - LD4是将内存里的值,读出来.而内存值在后续的代码中有设置
    - LD4 和 CON 指明了rI4最终的取值

因为打印的每行有10个数,所以代码中也有很多10,就是这个意思.

代码中对LD指令的用法有两种:

- LD1 =1-L=    LD2 =3=  这里用wexp,也就是字面量
- LDA PRIME,5           这里先计算M的值(一个具体的地址),再把内存中的值取出来

至此,mixal翻译的算法已经阅读完了.

## 关于查找质数

主流有两种方式,除了这两种,还有更多优化版本,
可以查找相关资料.

现在讨论这两种简单的主流方法:

- 暴力计算,拿一个数,然后判断是不是质数,时间消耗略大
- 筛子法,对于某类计算模式,执行多次,每次筛掉一部分数据,空间消耗略大
