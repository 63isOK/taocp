# 质数算法

质数的特点是约数除了1就是自己.

本次话题是:打印前500个质数,打印格式是每行10个,50行,
第一列显示前50个,第二列显示后50个,依次类推.

这个题目要分两部分:找500个质数;按格式打印.

## 算法

    P1. [Start table.] p[1]=2,n=3,j=1.(n表示下一个要判断的数,j表示已有质数数量.)
    P2. [n is prime.] j=j+1;p[j]=n.
    P3. [500 found?] if j==500, go to P9.
    P4. [Advance n.] n=n+2.
    P5. [k=2.] k=2.(用p[k]来测试n是否是一个质数.)
    P6. [p[k]\n?]. p[k]/n,商是q,余数是r.if r==0, go to P4.
    P7. [p[k] large?] if q <= p[k], go to p2.
    P8. [Advance k.] k=k+1, go to p6.
    P9. [Print title.] B[0]=title;print;b=1,m=1.
    P10. [Set up line.] p[m],p[50+m]...p[450+m] 添加到B[b].
    P11. [Print line.] print B[b],b=1-b,m=m+1.if m<=50,go to P10;其他 结束.

## 第一印象

使用了很多数学的方法来巧妙查找质数,
有优化的思想,比如说候选数并去掉了偶数(2的倍数),
最后完整地给出了问题的解.

B数组是一个buf缓冲,其实是有两个
`B[0]`和`B[1]`,一个做打印的时候,另一个做填充.
第一个疑问:支持并发吗,不然为啥要用两个缓冲.是否1个缓冲是否可以.

## 算法分析

第一步,先弄明白代码,再分析算法.

- 定义了一个L,表示前500个质数,也可以换成前2000个质数
- 最终打印在设备18上,u18是行打印设备,字块大小是24word
- PRIME,是数组的起始锚点,后续数组元素的具体位置都是基于PRIME和一个偏移量计算得出的
- BUF0/BUF1,用于存储打印标题和打印的质数
  - 打印标题共25byte,5word,小于一个字块,所以一次OUT就能打完
  - 在buf0/buf1的变量定义和最后的orig/con操作中,都考虑到了u18的字块大小:24
  - 特别说明一下,打印标题并不是存在BUF0中,而是BUF0前面的5word中

现在搞明白的第一个事是运行中的存储情况:

- 前500个质数放在0-499内存单元
- 打印标题5word,放在1995-1999
- BUF0,使用2000-2010;BUF1,使用2025-2035
- 运行代码,从3000开始

第二步,看代码中的查找质数的部分

之前也说到了,mixal写算法,过程重来都不是创造性的,
而是一个算法的翻译过程,整个mixal源码仅仅是将算法的11步做了一个翻译.

现在请跳到源码部分,对着源码完成注释部分.

下面是一些小细节的说明:

- 检查一个数是不是质数,为什么要从`p[1]`开始检测
  - `p[0] = 2, p[1] = 3`
  - 因为第一个添加到质数数组的数是2,第一个待检测的数是3
  - 每次更新待检测数,都是+2,这样排除了所有偶数
  - 也就不需要再去检查是否能整除2,因为永远不会整除2

前500个质数的查找,是按照算法来翻译的,mixal虽然用了一些
编程上的技巧,但这些技巧不是我们追求的,还是回归到算法本质.

第三部,看代码找那个的打印部分

- 将质数转成字符,存在rX时,只取了4个字符,为什么是4?
  - 第500个质数是3571,只有4个字符
  - 从实用角度出发,知道了前500个质数都不超过10000,取4个字符就合理了
  - 另外为了美观,第5个byte为空,整个打印就美观了
- rI5,`p[k]`中的k是如何影响程序的流程的?
  - 在将质数转换成字符之前,也就是取质数时
  - 用的是 LDA PRIME,5  这里可以看出`p[k]`中的k=rI5-1
  - 上面就是所有rI5和k的关系
  - rI5在一行之间,行于行之间,都有应用,最后程序退出也和rI5相关
- rI4,指明的是缓冲中,元素要存的位置,两个缓冲是如何切换的?
  - 涉及到rI4的有如下流程:
    - rI4=BUF1+10,之后一次将行元素写入,rI4最后指向BUF1
    - 处理完一行之后, LD4 24,4 这是重新指定rI4
    - LD4是将内存里的值,读出来.而内存值在后续的代码中有设置
    - LD4 和 CON 指明了rI4最终的取值

因为打印的每行有10个数,所以代码中也有很多10,就是这个意思.

代码中对LD指令的用法有两种:

- LD1 =1-L=    LD2 =3=  这里用wexp,也就是字面量
- LDA PRIME,5           这里先计算M的值(一个具体的地址),再把内存中的值取出来

至此,mixal翻译的算法已经阅读完了.

## 关于查找质数

主流有两种方式,除了这两种,还有更多优化版本,
可以查找相关资料.

现在讨论这两种简单的主流方法:

- 暴力计算,拿一个数,然后判断是不是质数,时间消耗略大
- 筛子法,对于某类计算模式,执行多次,每次筛掉一部分数据,空间消耗略大

## 书上关于demo的梳理

- 这个例子中处理非指令字的几种方式
  - CON 2 原始常量2,直接使用伪指令CON将常量放到指定内存中
  - CON BUF1+10 稍微复杂一点的处理
  - LD1 =1-L=   LD2 =3= 这种是字面量
    - mixal内部处理是: 为字面量定义一个变量label,再执行"LD 变量"
    - 相比之下,直接使用字面量会更加便捷
    - 更加有效的做法是 ENT1 1-L   ENT2 3
- 字面量(wexp)的提出是为了模仿机器
  - 还有本地变量和`*`都是如此
  - 本地变量,可理解为一个可重复定义的变量
  - 本地变量机制,来至于另一种机器语言
- 部分指令是不需要address的
  - CHAR HLT
  - 如果address写0,会影响美观,所以就忽略掉address
- 使用内存单元时,未指定的部分,会置为0
  - eg:ALF
  - 例外:通常3700-3999 不会会置0
- ORIG是可以和算术运算合用的
- 一个完整的mixal程序,最后一行应该是END指令
- 关于rIi寄存器的小技巧
  - 里面的值应该最后趋向0,方便判断
  - eg:给12个学生一个苹果,已发学生数是n
    - rI1可存n-12,当rI1为0时,表示每个人都领到了苹果

## 还有一些细小规则

下面都是关于mixal的小规则,帮助更好地理解什么能做,什么不能做.

- 符号用字符串表示,可以包含1-10个字符或数字,至少一个字符
  - 特殊符号是 dH dF dB, d的取值范围是单个数字
- 数number是一个字符串,可以包含1-10个数字
- 符号分两种:已定义的;将来引用的(也就是后面定义的)
- 原子表达式(不可再分割的)分3种:
  - 一个数number
  - 一个已定义的符号
  - 一个星号
- 表达式可分3种:
  - 原子表达式
  - 正负号 + 原子表达式
  - 原子表达式 + 二元操作符 + 表达式
    - 二元操作符包含"加减乘除 // : "
    - 表达式的计算是从左到右,并没有操作符优先级一说
- mix指令中的address部分可分4种:
  - 空的(等同于0)
  - 表达式
  - 将来引用
  - 字面量
- mix指令中的index部分可分2种:
  - 空的(等同于0)
  - 逗号后的表达式
- mix指令中的mod部分可分2种:
  - 空的(视具体指令而定)
  - 括号包围的部分
- W值可分2种:
  - mod后面的表达式
  - w值后面的w值
  - w值在某些场景下是非常强力的
- 星号,mixasm汇编器会用"正号+2byte"来代替星号
- 操作指令可分6种:
  - mix指令, 修改星号的值(+1)
  - EUQ, mixal的伪指令,w值,不修改星号
  - ORIG, 伪指令,w值,修改星号到指定值
  - CON, 伪指令,w值,修改星号的值(+1)
  - ALF, 伪指令将5个字符组成一个word,否则效果等同于CON(修改星号的值)
  - END, 伪指令,w值,(4:5)表示的是程序开始地址
- 字面量,w值,不超过10个字符,由两个等号包围,可以由将来引用
  - 效果和自定义一个变量类似
- 符号只对应一个值
  - 下面两种使用符号的情况是非法的:
    - 算术计算, LDA 2F+1
    - EQU/ORIG/CON中的address部分  CON 3F
