# 质数算法

质数的特点是约数除了1就是自己.

本次话题是:打印前500个质数,打印格式是每行10个,50行,
第一列显示前50个,第二列显示后50个,依次类推.

这个题目要分两部分:找500个质数;按格式打印.

## 算法

    P1. [Start table.] p[1]=2,n=3,j=1.(n表示下一个要判断的数,j表示已有质数数量.)
    P2. [n is prime.] j=j+1;p[j]=n.
    P3. [500 found?] if j==500, go to P9.
    P4. [Advance n.] n=n+2.
    P5. [k=2.] k=2.(用p[k]来测试n是否是一个质数.)
    P6. [p[k]\n?]. p[k]/n,商是q,余数是r.if r==0, go to P4.
    P7. [p[k] large?] if q <= p[k], go to p2.
    P8. [Advance k.] k=k+1, go to p6.
    P9. [Print title.] B[0]=title;print;b=1,m=1.
    P10. [Set up line.] p[m],p[50+m]...p[450+m] 添加到B[b].
    P11. [Print line.] print B[b],b=1-b,m=m+1.if m<=50,go to P10;其他 结束.

## 第一印象

使用了很多数学的方法来巧妙查找质数,
有优化的思想,比如说候选数并去掉了偶数(2的倍数),
最后完整地给出了问题的解.

B数组是一个buf缓冲,其实是有两个
`B[0]`和`B[1]`,一个做打印的时候,另一个做填充.
第一个疑问:支持并发吗,不然为啥要用两个缓冲.

## 算法分析

## 关于查找质数

主流有两种方式,除了这两种,还有更多优化版本,
可以查找相关资料.

现在讨论这两种简单的主流方法:

- 暴力计算,拿一个数,然后判断是不是质数,时间消耗略大
- 筛子法,对于某类计算模式,执行多次,每次筛掉一部分数据,空间消耗略大
